# 2019.12.18. (ìˆ˜)

| í•™ìŠµí˜•íƒœ    | [x] ê°œë³„ [] 2ì¸ 1ì¡° [] íŒ€ë³„                                  |
| ----------- | ------------------------------------------------------------ |
| êµ¬ì„±ì›      | ì´ì§€í›ˆ                                                       |
| ì¼ì •        | 09:00 ~ 13:00                                                |
| ë°ì¼ë¦¬ ëª©í‘œ | ë°ì´í„° ì‚¬ì´ì–¸ìŠ¤ ê¸°ì´ˆ<br /> - Chapter 2. Optimization Problem<br /> - Chapter 3. Graph-theoretic Models |

- ## Chapter 2. Optimization Problem

- í•µì‹¬ í‚¤ì›Œë“œ

  - íƒìš• ì•Œê³ ë¦¬ì¦˜ (Greedy Algorithm)
  - ë¬´ì°¨ë³„ ëŒ€ì… ì•Œê³ ë¦¬ì¦˜ (Brute Force Algorithm)
  - ë™ì  í”„ë¡œê·¸ë˜ë° (Dynamic Programming)

-  í•™ìŠµ ë‚´ìš©

  - íƒìš• ì•Œê³ ë¦¬ì¦˜

    - ê²°ì •í•  ë•Œ ë§ˆë‹¤ ê·¸ ìˆœê°„ì— ìµœì ì´ë¼ê³  ìƒê°ë˜ëŠ” ê²ƒì„ ì„ íƒí•´ ë‚˜ê°€ëŠ” ë°©ì‹ìœ¼ë¡œ ìµœì¢… ë‹µì— ë„ë‹¬í•˜ëŠ” ë°©ì‹
    - ì¥ì 
      - êµ¬í˜„í•˜ê¸° ì‰¬ì›€
      - ë§¤ìš° ë¹ ë¦„
    - ë‹¨ì 
      - ìµœì ì¼ ìˆ˜ë„ ìˆê³  ì•„ë‹ ìˆ˜ë„ ìˆëŠ” í•´ë¥¼ êµ¬í•¨
      - êµ¬í•œ í•´ê°€ ìµœì ì— ì–¼ë§ˆë‚˜ ê°€ê¹Œìš´ì§€ ëª¨ë¦„

  - ë¬´ì°¨ë³„ ëŒ€ì… ì•Œê³ ë¦¬ì¦˜

    - íƒìš• ì•Œê³ ë¦¬ì¦˜ì„ ëŒ€ì²´í•  ìˆ˜ ìˆëŠ” ì•Œê³ ë¦¬ì¦˜
    - í•­ëª©ì˜ ì¡°í•© ê°€ëŠ¥í•œ ìˆ˜ë¥¼ ì—´ê±°í•œ í›„, ì „ì²´ í•©ì´ ê°€ì¤‘ì¹˜ë¥¼ ë„˜ì–´ê°€ëŠ” ê²ƒì€ ì œê±°
    - ë‚¨ì€ ì¡°í•© ì¤‘ ê°€ì¥ í° ê°’ì„ ê°€ì§€ëŠ” ì¡°í•©ì„ ì•„ë¬´ê±°ë‚˜ í•˜ë‚˜ íƒí•¨
    - íƒìƒ‰ íŠ¸ë¦¬ êµ¬í˜„
      - íŠ¸ë¦¬ëŠ” ë¿Œë¦¬ì—ì„œ ì‹œì‘í•´ì„œ ìœ„ì—ì„œ ì•„ë˜ë¡œ ë§Œë“¤ì–´ì§
      - ì²«ë²ˆì§¸ ì›ì†ŒëŠ” ê³ ë ¤í•´ì•¼í•˜ëŠ” ë¬¼ê±´ ì¤‘ ì„ íƒ
        - knapsackì— ê·¸ ë¬¼ê±´ì„ ìœ„í•œ ê³µê°„ì´ ìˆìœ¼ë©´, ë…¸ë“œëŠ” ë¬¼ê±´ì„ ì„ íƒí•œ ê²°ê³¼ë¥¼ ë°˜ì˜í•˜ì—¬ ë§Œë“¤ì–´ì§
          - ê´€ë¡€ì ìœ¼ë¡œ ì™¼ìª½ ìì‹ìœ¼ë¡œ ê·¸ë¦¼
        - ì„ íƒí•˜ì§€ ì•ŠëŠ” ê²°ê³¼ë„ íƒìƒ‰í•¨
          - ì˜¤ë¥¸ìª½ ìì‹ ê·¸ë¦¼
      - ì´ ê³¼ì •ì„ ë‹¨ë§ ë…¸ë“œê°€ ì•„ë‹Œ ìì‹ì—ê²Œ ì¬ê·€ì ìœ¼ë¡œ ì ìš© (DFS)
      - ìµœì¢…ì ìœ¼ë¡œ ì œí•œ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ë…¸ë“œ ì¤‘ ê°€ì¥ í° ê°’ì„ ê°€ì§„ ë…¸ë“œë¥¼ ì„ íƒ

  - ê±”ì‚° ë³µì¡ë„

    - ì‹œê°„ì€ ë§Œë“¤ì–´ì§„ ë…¸ë“œ ìˆ˜ì™€ ì—°ê´€

    - ë ˆë²¨ì˜ ìˆ˜ëŠ” ì„ íƒí•  ìˆ˜ ìˆëŠ” ë¬¼ê±´ì˜ ê°œìˆ˜

    - ë ˆë²¨ iì—ì„œ ë…¸ë“œì˜ ìˆ˜ëŠ” 2^ğ‘–

    - ë”°ë¼ì„œ nê°œì˜ ë¬¼ê±´ì´ ìˆì„ ë•Œ ë…¸ë“œì˜ ê°œìˆ˜ëŠ”

      - â—¦Î£(ğ‘–=0, ğ‘–=ğ‘›)(2^ğ‘–)
        â—¦I.e., O(2^ğ‘›+1 )

    - ë¶„ëª…í•œ ìµœì í™” : ì œí•œ ì¡°ê±´ì„ ì–´ê¸°ëŠ” íŠ¸ë¦¬ëŠ” íƒìƒ‰í•˜ì§€ ì•ŠìŒ (ex. ë„ˆë¬´ ë§ì€ cal)

      - ë³µì¡ë„ëŠ” ë¶ˆë³€

    - ë¬´ì°¨ë³„ ëŒ€ì…ë²•ì€ ì“¸ëª¨ ì—†ëŠ”ê±¸ê¹Œ?

      - ```python
        def maxVal(toConsider, avail):
            """Assumes toConsider a list of items, avail a weight
               Returns a tuple of the total value of a solution to the
                 0/1 knapsack problem and the items of that solution"""
            if toConsider == [] or avail == 0:
                result = (0, ())
                #ëª¨ë“  nodeë¥¼ ë³´ê³  íŒë‹¨í•˜ëŠ”ê²Œ ì•„ë‹˜, nodeê°€ ìƒì„±ë  ë•Œ ë§ˆë‹¤ ì´ì „ ë…¸ë“œì™€ ë¹„êµí•˜ì—¬ ë” ì¢‹ì€ nodeë¥¼ ê°’ìœ¼ë¡œ ì„ íƒ
                #ê°€ì¥ ì¢‹ì€ ë‹µì´ ì„ íƒë  ê°€ëŠ¥ì„±ì´ ìˆìŒ
            elif toConsider[0].getCost() > avail:
                #Explore right branch only
                #ë°°ë‚­ì— ë¬¼ê±´ì„ ë” ë„£ì„ ìˆ˜ ì—†ì–´ì„œ ì˜¤ë¥¸ìª½ ê°€ì§€ë§Œ íƒìƒ‰
                result = maxVal(toConsider[1:], avail)
            else:
                nextItem = toConsider[0]
                #Explore left branch
                withVal, withToTake = maxVal(toConsider[1:],
                                             avail - nextItem.getCost())
                # í˜„ì¬ ìš”ì†Œë¥¼ ì œì™¸í•œ toConsiderê³¼ availì—ì„œ ë‹¤ìŒ ìš”ì†Œì˜ ë¹„ìš©ì„ ëº€ ê°’ì„ ë„£ì–´ì¤Œ
                withVal += nextItem.getValue()
                #Explore right branch
                withoutVal, withoutToTake = maxVal(toConsider[1:], avail)
                #Choose better branch
                if withVal > withoutVal:
                    result = (withVal, withToTake + (nextItem,))
                else:
                    result = (withoutVal, withoutToTake)
            return result
        ```

      - `toConsider : ì•„ì§ ê³ ë ¤í•˜ì§€ ì•Šì€ íŠ¸ë¦¬ì˜ ìƒë‹¨ ë…¸ë“œì— ìˆëŠ” ë¬¼ê±´ ë¦¬ìŠ¤íŠ¸(ì¬ê·€ í˜¸ì¶œì—ì„œ ì´ì „ í˜¸ì¶œê³¼ ì—°ê´€)`

      - `avail : ë¦¬ìŠ¤íŠ¸ì— ê³ ë ¤í•  ìš”ì†Œê°€ ìˆëŠ”ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” index, ë‚¨ì€ ì—¬ìœ  ê³µê°„ì˜ ì–‘`

      - Chapter 1. ì—ì„œì˜ ë‹µ : 284, 318, 318 // ìµœì í™”ì˜ ë‹µ : 353

        - ë” ë‚˜ì€ ë‹µì„ ì¤Œ

        - ë¹¨ë¦¬ ëë‚¨

        - í•˜ì§€ë§Œ ìƒ˜í”Œì˜ ê°¯ìˆ˜ê°€ ì ìŒ (2^8)

          - ì„ íƒí•  ìˆ˜ ìˆëŠ” ë©”ë‰´ê°€ í›¨ì”¬ ë§ì„ ë•Œ ì–´ë–¤ ì¼ì´ ì¼ì–´ë‚˜ëŠ”ì§€ í™•ì¸í•´ ë´ì•¼í•¨

          - ë” í° ì˜ˆ

            - ```python
              import random
              
              def buildLargeMenu(numItems, maxVal, maxCost):
                  items = []
                  for i in range(numItems):
                      items.append(Food(str(i),
                                        random.randint(1, maxVal),
                                        random.randint(1, maxCost)))
                  return items
              
              for numItems in (5, 10, 15, 20, 25, 30, 35, 40, 45):
                  print('Try a menu with', numItems, 'items')
                  items = buildLargeMenu(numItems, 90, 250)
                  testMaxVal(items, 750, False)  
              ```

            - ë©”ë‰´ì˜ ê°¯ìˆ˜ê°€ 30ê°œë¥¼ ë„˜ì–´ê°€ëŠ” ìˆœê°„ë¶€í„° ëŠë ¤ì§€ê¸° ì‹œì‘í•¨

            - ì´ë¡ ì ìœ¼ë¡œëŠ” ê°€ë§ì´ ì—†ìŒ

            - í•˜ì§€ë§Œ ë™ì  í”„ë¡œê·¸ë˜ë°ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆìŒ

  - ë™ì  í”„ë¡œê·¸ë˜ë°

    - í”¼ë³´ë‹¤ì¹˜ì˜ ì¬ê·€ì  êµ¬í˜„

      - ```python
        def fib(n):
            if n == 0 or n == 1:
                return 1
            else:
                return fib(n - 1) + fib(n - 2)
        
        for i in range(121):
            print('fib(' + str(i) + ') =', fib(i))
        ```

      - 30ë²ˆì§¸ ë¶€í„°ëŠ” ëŠë ¤ì§€ê¸° ì‹œì‘í•¨

      - ë°˜ë³µì‘ì—…ì€ ë¹„íš¨ìœ¨ì 

        - í…Œì´ë¸”ì„ ë§Œë“¤ì–´ ì§€ê¸ˆê¹Œì§€ í•œ ê²ƒì„ ê¸°ë¡
          - fib(x)ë¥¼ ê³„ì‚°í•˜ê¸° ì „ì—, fib(x)ê°€ í…Œì´ë¸”ì— ì´ë¯¸ ì €ì¥ë˜ì–´ ìˆëŠ”ì§€ë¥¼ í™•ì¸
            - ìˆë‹¤ë©´, ê°’ì„ ê°€ì ¸ì˜´
            - ì—†ë‹¤ë©´, ê³„ì‚°í•˜ê³  í…Œì´ë¸”ì— ì €ì¥
        - ì´ë¥¼ memoizationì´ë¼ ë¶€ë¦„
          - ì‹œê°„ì„ ê³µê°„ê³¼ ë§ë°”ê¿ˆ

    - Memoization Fib

      - ```python
        def fastFib(n, memo = {}):
            """Assumes n is an int >= 0, memo used only by recursive calls
               Returns Fibonacci of n"""
            if n == 0 or n == 1:
                return 1
            try:
                return memo[n]
            except KeyError:
                result = fastFib(n-1, memo) + fastFib(n-2, memo)
                memo[n] = result
                return result
        
        for i in range(121):
           print('fib(' + str(i) + ') =', fastFib(i))
        ```

        - ë…¼ë¦¬ íë¦„ì— ë§ì¶°ì„œ try exceptë¥¼ ì‚¬ìš©
        - ifë¬¸ìœ¼ë¡œ ì‹œì‘í•˜ì—¬ key & thenìœ¼ë¡œ ëë‚˜ëŠ” ë°©ë²• ë³´ë‹¤ ì½ê¸°ë„ í¸í•¨

    - í™œìš©ë°©ì•ˆ

      - ëª¨ë“  ë¬¸ì œì— ë§ëŠ” ë°©ë²•ì€ ì•„ë‹˜
      - ë³µì¡í•œ ë¬¸ì œë¥¼ ê°„ë‹¨í•œ ì—¬ëŸ¬ê°œì˜ ë¬¸ì œë¡œ ë‚˜ëˆ„ì–´ í‘¸ëŠ” ë°©ë²•
      - **ìµœì  ë¶€ë¶„ êµ¬ì¡°**
        - ì „ì—­ ìµœì í•´ë¥¼ ì§€ì—­ ë¶€ë¶„ ë¬¸ì œì—ì„œ ìµœì  í•´ë¥¼ ê²°í•©í•¨ìœ¼ë¡œì¨ ì–»ì„ ìˆ˜ ìˆëŠ” ë¬¸ì œ
        - `for x >1, fib(x) = fib(x - 1) + fib(x - 2)`
      - **ì¤‘ë³µ ë¶€ë¶„ ë¬¸ì œ**
        - ìµœì  í•´ë¥¼ êµ¬í•  ë•Œ ê°™ì€ ë¬¸ì œë¥¼ ì—¬ëŸ¬ë²ˆ í’€ì–´ì•¼ í•˜ëŠ” ë¬¸ì œ
        - fib(x)ë¥¼ í•œë²ˆ ê³„ì‚°í•˜ê±°ë‚˜ ì—¬ëŸ¬ë²ˆ ê³„ì‚°í•˜ëŠ” ê²½ìš°
        - ë³‘í•©ì •ë ¬ (merge sort)ì—ì„  ìµœì  ë¶€ë¶„ êµ¬ì¡°ê°€ ì˜ ì‘ë™í•¨
          - ê·¸ë ‡ë‹¤ë©´ ë³‘í•©ì •ë ¬ì´ ì¤‘ë³µ ë¶€ë¶„ ë¬¸ì œì¸ê°€?
            - No, ë³‘í•©ê³¼ ì •ë ¬ì—ì„  ê·¸ ë•Œ ë§ˆë‹¤ ê°ê¸° ë‹¤ë¥¸ ê³„ì‚°ì„ í•´ì•¼í•¨

    - 0 / 1 knapsack ë¬¸ì œì—ì„œëŠ”?

      - ì¤‘ë³µì´ ì—†ëŠ” íƒìƒ‰íŠ¸ë¦¬ì—ì„œ DPë¥¼ ì‚¬ìš©ê°€ëŠ¥
        - ë‹µì€ ì–»ì„ ìˆ˜ ìˆê² ì§€ë§Œ, ì†ë„ê°€ ë¹ ë¥´ì§„ ì•ŠìŒ
        - ë°°ë‚­ì„ ê³ ë¥¼ë•Œ ê°™ì€ ë¶€ë¶„ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ
      - ì¤‘ë³µì´ ìˆëŠ” íƒìƒ‰íŠ¸ë¦¬ì—ì„œëŠ” ì†ë„ì˜ í–¥ìƒì„ ê¸°ëŒ€í•  ìˆ˜ ìˆìŒ

    -  Memoë¥¼ ì ìš©ì‹œí‚¨ maxVal

      - ```python
        def fastMaxVal(toConsider, avail, memo = {}):
            """Assumes toConsider a list of subjects, avail a weight
                 memo supplied by recursive calls
               Returns a tuple of the total value of a solution to the
                 0/1 knapsack problem and the subjects of that solution"""
            if (len(toConsider), avail) in memo:
                result = memo[(len(toConsider), avail)]
            elif toConsider == [] or avail == 0:
                result = (0, ())
            elif toConsider[0].getCost() > avail:
                #Explore right branch only
                result = fastMaxVal(toConsider[1:], avail, memo)
            else:
                nextItem = toConsider[0]
                #Explore left branch
                withVal, withToTake =
                         fastMaxVal(toConsider[1:],
                                    avail - nextItem.getCost(), memo)
                withVal += nextItem.getValue()
                #Explore right branch
                withoutVal, withoutToTake = fastMaxVal(toConsider[1:],
                                                        avail, memo)
                #Choose better branch
                if withVal > withoutVal:
                    result = (withVal, withToTake + (nextItem,))
                else:
                    result = (withoutVal, withoutToTake)
            memo[(len(toConsider), avail)] = result
            return result
        
        def testMaxVal(foods, maxUnits, algorithm, printItems = True):
            print('Menu contains', len(foods), 'items')
            print('Use search tree to allocate', maxUnits,
                  'calories')
            val, taken = algorithm(foods, maxUnits)
            if printItems:
                print('Total value of items taken =', val)
                for item in taken:
                    print('   ', item)
                  
        for numItems in (5, 10, 15, 20, 25, 30, 35, 40, 45, 50):
            items = buildLargeMenu(numItems, 90, 250)
            testMaxVal(items, 750, fastMaxVal, True)
        ```

        - ì„¸ë²ˆì§¸ ì¸ìˆ˜ë¡œ memoë¥¼ ì¶”ê°€
        - ë©”ëª¨ì˜ í•µì‹¬ì€ íŠœí”Œ
          - `(ê³ ë ¤í•´ì•¼ í•˜ëŠ” ë‚¨ì€ ë¬¼ê±´, ê°€ëŠ¥í•œ ë¬´ê²Œ)`
          - ê³ ë ¤í•´ì•¼ í•˜ëŠ” ë‚¨ì€ ë¬¼ê±´ì€ ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„ 
            - `len(toConsider)`
        - í•¨ìˆ˜ì˜ ëª¸ì²´ê°€ ì²«ë²ˆì§¸ë¡œ í•˜ëŠ” ì¼ì€ ì£¼ì–´ì§„ ê°€ëŠ¥í•œ ë¬´ê²Œì—ì„œ ë¬¼ê±´ì˜ ìµœì ì˜ ì„ íƒì´ ì´ë¯¸ ë©”ëª¨ì— ìˆëŠ”ì§€ í™•ì¸
        - í•¨ìˆ˜ì˜ ëª¸ì²´ê°€ ë§ˆì§€ë§‰ìœ¼ë¡œ í•˜ëŠ” ì¼ì€ ë©”ëª¨ë¥¼ ê°±ì‹ 

      - ê°€ëŠ¥í•œ ì´ìœ 

        - ì§€ìˆ˜í•¨ìˆ˜
        - ê³„ì‚° ë³µì¡ë„ëŠ” ë¯¸ë¬˜í•˜ë‹¤
        - fastMaxValì˜ ì‹¤í–‰ ì‹œê°„ì€ ì„œë¡œ ë‹¤ë¥¸ ìŒ <toConsider, avail>ì— ì˜í•´ ê²°ì •
          - toConsiderì´ ê°€ëŠ¥í•œ ê°’ì€ len(items)ì— ì˜í•´ ì œí•œë¨
          - availì´ ê°€ëŠ¥í•œ ê°’ì€ ë‹¤ì†Œ íŠ¹ì§•ì§“ê¸° ì–´ë ¤ì›€
            - ì„œë¡œ ë‹¤ë¥¸ ë¬´ê²Œì˜ í•©ì— ì˜í•´ ì œí•œë¨

- ìš”ì•…

  - ì‹¤ì œë¡œ ì¤‘ìš”í•œ ë§ì€ ë¬¸ì œë“¤ì€ Optimization problemsë¡œ ì“¸ ìˆ˜ ìˆìŒ
  - Greedy algorithmì€ ëŒ€ë¶€ë¶„ ì ë‹¹í•œ ë‹µì„ ì¤Œ (ìµœì ì€ ì•„ë‹ ìˆ˜ ìˆìŒ)
  - ìµœì  í•´ë¥¼ ì°¾ëŠ” ê²ƒì€ ê±°ì˜ exponentially hard
  - í•˜ì§€ë§Œ Dynamic Programmingì€ ìµœì í™” ë¬¸ì œì˜ ë¶€ë¶„ë¬¸ì œì—ì„œ ë‚˜ì€ í¼í¬ë¨¼ìŠ¤ë¥¼ ë³´ì—¬ì¤Œ
    - ìµœì  ë¶€ë¶„ êµ¬ì¡°ì™€ ì¤‘ë³µ ë¶€ë¶„ ë¬¸ì œë¥¼ ê°€ì§€ëŠ” ê²½ìš°
    - í•´ëŠ” í•­ìƒ ë§ìŒ
    - ì ë‹¹í•œ ìˆœí™˜ í•˜ì—ì„œëŠ” ë¹ ë¦„
    - ê·¼ì‚¬ê°€ ì•„ë‹Œ ìµœì í™” í•´ë²•ì´ êµ¬í•´ì§
  
- algorithm

  - ```python
    class Food(object):
        def __init__(self, n, v, w):
            self.name = n
            self.value = v
            self.calories = w
        def getValue(self):
            return self.value
        def getCost(self):
            return self.calories
        def density(self):
            return self.getValue()/self.getCost()
        def __str__(self):
            return self.name + ': <' + str(self.value)\
                     + ', ' + str(self.calories) + '>'
    
    def buildMenu(names, values, calories):
        menu = []
        for i in range(len(values)):
            menu.append(Food(names[i], values[i],
                              calories[i]))
        return menu
    
    def greedy(items, maxCost, keyFunction):
        """Assumes items a list, maxCost >= 0,
             keyFunction maps elements of Items to numbers"""
        itemsCopy = sorted(items, key = keyFunction,
                           reverse = True)
        result = []
        totalValue, totalCost = 0.0, 0.0
        for i in range(len(itemsCopy)):
            if (totalCost+itemsCopy[i].getCost()) <= maxCost:
                result.append(itemsCopy[i])
                totalCost += itemsCopy[i].getCost()
                totalValue += itemsCopy[i].getValue()
        return (result, totalValue)
    
    def testGreedy(items, constraint, keyFunction):
        taken, val = greedy(items, constraint, keyFunction)
        print('Total value of items taken =', val)
        for item in taken:
            print('   ', item)
    
    def testGreedys(foods, maxUnits):
        print('Use greedy by value to allocate', maxUnits,
              'calories')
        testGreedy(foods, maxUnits, Food.getValue)
        print('\nUse greedy by cost to allocate', maxUnits,
              'calories')
        testGreedy(foods, maxUnits,
                   lambda x: 1/Food.getCost(x))
        print('\nUse greedy by density to allocate', maxUnits,
              'calories')
        testGreedy(foods, maxUnits, Food.density)
    
    def maxVal(toConsider, avail):
        """Assumes toConsider a list of items, avail a weight
           Returns a tuple of the total value of a solution to the
             0/1 knapsack problem and the items of that solution"""
        if toConsider == [] or avail == 0:
            result = (0, ())
        elif toConsider[0].getCost() > avail:
            #Explore right branch only
            result = maxVal(toConsider[1:], avail)
        else:
            nextItem = toConsider[0]
            #Explore left branch
            withVal, withToTake = maxVal(toConsider[1:],
                                         avail - nextItem.getCost())
            withVal += nextItem.getValue()
            #Explore right branch
            withoutVal, withoutToTake = maxVal(toConsider[1:], avail)
            #Choose better branch
            if withVal > withoutVal:
                result = (withVal, withToTake + (nextItem,))
            else:
                result = (withoutVal, withoutToTake)
        return result
    
    def testMaxVal(foods, maxUnits, printItems = True):
        print('Use search tree to allocate', maxUnits,
              'calories')
        val, taken = maxVal(foods, maxUnits)
        print('Total value of items taken =', val)
        if printItems:
            for item in taken:
                print('   ', item)
    
    names = ['wine', 'beer', 'pizza', 'burger', 'fries',
             'cola', 'apple', 'donut', 'cake']
    values = [89,90,95,100,90,79,50,10]
    calories = [123,154,258,354,365,150,95,195]
    foods = buildMenu(names, values, calories)
    
    testGreedys(foods, 750)
    print('')
    testMaxVal(foods, 750)
    
    import random
    
    def buildLargeMenu(numItems, maxVal, maxCost):
        items = []
        for i in range(numItems):
            items.append(Food(str(i),
                              random.randint(1, maxVal),
                              random.randint(1, maxCost)))
        return items
    
    #for numItems in (5, 10, 15, 20, 25, 30, 35, 40, 45):
    #    print('Try a menu with', numItems, 'items')
    #    items = buildLargeMenu(numItems, 90, 250)
    #    testMaxVal(items, 750, False)  
    
    def fib(n):
        if n == 0 or n == 1:
            return 1
        else:
            return fib(n - 1) + fib(n - 2)
    
    #for i in range(121):
    #    print('fib(' + str(i) + ') =', fib(i))
    
    
    def fastFib(n, memo = {}):
        """Assumes n is an int >= 0, memo used only by recursive calls
           Returns Fibonacci of n"""
        if n == 0 or n == 1:
            return 1
        try:
            return memo[n]
        except KeyError:
            result = fastFib(n-1, memo) + fastFib(n-2, memo)
            memo[n] = result
            return result
    
    #for i in range(121):
    #    print('fib(' + str(i) + ') =', fastFib(i))
    
    def fastMaxVal(toConsider, avail, memo = {}):
        """Assumes toConsider a list of subjects, avail a weight
             memo supplied by recursive calls
           Returns a tuple of the total value of a solution to the
             0/1 knapsack problem and the subjects of that solution"""
        if (len(toConsider), avail) in memo:
            result = memo[(len(toConsider), avail)]
        elif toConsider == [] or avail == 0:
            result = (0, ())
        elif toConsider[0].getCost() > avail:
            #Explore right branch only
            result = fastMaxVal(toConsider[1:], avail, memo)
        else:
            nextItem = toConsider[0]
            #Explore left branch
            withVal, withToTake =\
                     fastMaxVal(toConsider[1:],
                                avail - nextItem.getCost(), memo)
            withVal += nextItem.getValue()
            #Explore right branch
            withoutVal, withoutToTake = fastMaxVal(toConsider[1:],
                                                    avail, memo)
            #Choose better branch
            if withVal > withoutVal:
                result = (withVal, withToTake + (nextItem,))
            else:
                result = (withoutVal, withoutToTake)
        memo[(len(toConsider), avail)] = result
        return result
    
    def testMaxVal(foods, maxUnits, algorithm, printItems = True):
        print('Menu contains', len(foods), 'items')
        print('Use search tree to allocate', maxUnits,
              'calories')
        val, taken = algorithm(foods, maxUnits)
        if printItems:
            print('Total value of items taken =', val)
            for item in taken:
                print('   ', item)
              
    #for numItems in (5, 10, 15, 20, 25, 30, 35, 40, 45, 50):
    #    items = buildLargeMenu(numItems, 90, 250)
    #    testMaxVal(items, 750, fastMaxVal, True)
    
    ```

  - 



## Chapter 3. Graph-theoretic Models

- í•µì‹¬ í‚¤ì›Œë“œ

  - ê·¸ë˜í”„ (Graph)
  - ê¹Šì´ ìš°ì„  íƒìƒ‰ (Depth-First Search)
  - ë„ˆë¹„ ìš°ì„  íƒìƒ‰ (Breadth-First Search)

- í•™ìŠµ ë‚´ìš©

  - ê·¸ë˜í”„ëŠ” ê¼­ì§“ì  í˜¹ì€ ë…¸ë“œë¡œ ì´ë£¨ì–´ì§€ê³ , ì´ë“¤ì€ ê°„ì„  í˜¹ì€ ë³€ìœ¼ë¡œ ì´ë£¨ì–´ì§

  - ë…¸ë“œì˜ ì§‘í•©

    - ê° ë…¸ë“œëŠ” ë‹¤ë¥¸ ë…¸ë“œì™€ ê´€ê³„ëœ ì •ë³´ë¥¼ ë‹´ê³  ìˆìŒ
    - ì˜ˆ : í•™ìƒì˜ ì„±ì 

  - ê°„ì„  (ë³€ì´)

    - ë…¸ë“œì˜ ìŒì„ ì—°ê²°
    - ê°„ì„ ì„ ì´ìš©í•´ ê·¸ë˜í”„ë¥¼ ë§Œë“œëŠ” 2ê°€ì§€ ë°©ë²•
      - ë¬´ë°©í–¥ (ê·¸ë˜í”„)
      - ìœ í–¥ (ì‹œì‘ì (ë¶€ëª¨)ê³¼ ë„ì°©ì (ìì‹))
        - ê°€ì¤‘ì¹˜ í˜¹ì€ ë¬´ê°€ì¤‘ì¹˜

  - ì‚¬ìš© ì˜ˆì‹œ

    - ê°œì²´ ì‚¬ì´ì˜ ê´€ê³„ í‘œì‹œ
      - ì˜ˆ : íŒŒë¦¬ì—ì„œ ëŸ°ë˜ìœ¼ë¡œ ì—¬í–‰ì„ ê°ˆ ë•Œ, ë…¸ë“œëŠ” ê° ë„ì‹œ, ì—°ê²°ì€ ë„ì‹œ ì‚¬ì´ ë ˆì¼
      - í•œ ë¶„ì ë‚´ì˜ ì›ìë“¤ì´ ì„œë¡œ ì–´ë–»ê²Œ ì—°ê´€ë˜ì–´ ìˆëŠ”ê°€
      - ì¡°ìƒê´€ê³„

  - íŠ¸ë¦¬ : ì¤‘ìš”í•˜ê³  íŠ¹ë³„í•œ ê²½ìš°

    - nodeìŒì´ í•˜ë‚˜ì˜ ê²½ë¡œë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ” ìœ í–¥ê·¸ë˜í”„ì˜ íŠ¹ë³„í•œ ê²½ìš°
      - ëƒ…ìƒ‰ ë¬¸ì œë¥¼ í’€ ë•Œ ì‚¬ìš©í–ˆë˜ íƒìƒ‰íŠ¸ë¦¬

  - ìœ ìš©í•œ ì´ìœ 

    - ì„¸ìƒì— ì¡´ì¬í•˜ëŠ” ì—¬ëŸ¬ ê´€ê³„ëŠ” ê·¸ë˜í”„ë¡œ í‘œí˜„í•˜ê¸° ì í•©
    - ì»´í“¨í„° ë„¤íŠ¸ì›Œí¬, êµí†µ ë„¤íŠ¸ì›Œí¬, ê¸ˆìœµ ë„¤íŠ¸ì›Œí¬, ì •ì¹˜ ë„¤íŠ¸ì›Œí¬, ë²”ì£„ ë„¤íŠ¸ì›Œí¬, ì‚¬íšŒ ë„¤íŠ¸ì›Œí¬ ë“±
    - ê·¸ë˜í”„ê°€ ë„¤íŠ¸ì›Œí¬ ë‚´ ìš”ì†Œë“¤ ê°„ì˜ ê´€ê³„ë§Œ ë‹´ê³  ìˆëŠ” ê²ƒì´ ì•„ë‹ˆë¼ êµ¬ì¡°ë¥¼ í†µí•œ ì¶”ë¡ ë„ ë„ì™€ì¤Œ
      - ìš”ì†Œ ê°„ ê²½ë¡œì˜ ë°°ì—´ ì°¾ê¸° : Aì—ì„œ Bë¡œ ê°€ëŠ” ê²½ë¡œê°€ ìˆëŠ”ê°€?
      - ìš”ì†Œ ê°„ ìµœì†Œ ë¹„ìš© ê²½ë¡œ ì°¾ê¸° (ìµœë‹¨ ê²½ë¡œ ë¬¸ì œ)
      - ê·¸ë˜í”„ë¥¼ ì—°ê²°ëœ ìš”ì†Œë“¤ì˜ ì§‘í•©ìœ¼ë¡œ ë¶„í• í•˜ê¸° (ê·¸ë˜í”„ ë¶„í•  ë¬¸ì œ)
      - ì—°ê²°ëœ ìš”ì†Œë“¤ì˜ ì§‘í•©ìœ¼ë¡œ ë¶„í• í•˜ëŠ” ê°€ì¥ íš¨ìœ¨ì ì¸ ë°©ë²• ì°¾ê¸° (ìµœì†Œ ì»· ìµœëŒ€ ìœ ëŸ‰ ë¬¸ì œ)

    

  - ìµœì´ˆ ê·¸ë˜í”„ ì´ë¡  ì‚¬ìš© ì‚¬ë¡€

    - ì¾¨ë‹ˆíˆìŠ¤ë² ë¥´í¬ ë‹¤ë¦¬ 
      - 7ê°œì˜ ë‹¤ë¦¬ë¥¼ ë”± í•œë²ˆì”©ë§Œ ê±¸ì–´ì„œ ëª¨ë“  ì„¬ì„ ë‹¤ ë°©ë¬¸í•  ìˆ˜ ìˆì„ê¹Œ?
    - ë ˆì˜¨ í•˜ë¥´íŠ¸ ì˜¤ì¼ëŸ¬ ëª¨ë¸
      - ê° ì„¬ì„ ê¼­ì§“ì ìœ¼ë¡œ
      - ê° ë‹¤ë¦¬ë¥¼ ë¬´ë°©í–¥ ê°„ì„ ìœ¼ë¡œ
      - ë¬´ì˜ë¯¸í•œ ì •ë³´ëŠ” ë²„ë¦¬ê³  ì¶”ìƒí™”í•œ ëª¨ë¸ë§
        - ì„¬ì˜í¬ê¸°
        - ë‹¤ë¦¬ì˜ ê¸¸ì´
      - ê° ê°„ì„ ì„ ë”± í•œ ë²ˆì”©ë§Œ í¬í•¨í•˜ëŠ” ê²½ë¡œê°€ ìˆëŠ”ê°€?
        - No

  - ê·¸ë˜í”„ì˜ êµ¬í˜„ê³¼ ì‚¬ìš©

    - ê·¸ë˜í”„ ë§Œë“¤ê¸°

      - node, edge, connection

    - ê·¸ë˜í”„ ì‚¬ìš©

      - ë‘ ìš”ì†Œ ì‚¬ì´ì— ì—°ì†ëœ ê°„ì„ ì´ ìˆëŠ”ì§€ í™•ì¸
      - ìµœì†Œ ë¹„ìš© í˜¹ì€ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
      - ê·¸ë˜í”„ ë¶„í•  ë¬¸ì œë¡œ ì ‘ê·¼

    - ```python
      class Node(object):
          def __init__(self, name):
              """Assumes name is a string"""
              self.name = name
          def getName(self):
              return self.name
          def __str__(self):
              return self.name
      
      class Edge(object):
          def __init__(self, src, dest):
              """Assumes src and dest are nodes"""
              self.src = src
              self.dest = dest
          def getSource(self):
              return self.src
          def getDestination(self):
              return self.dest
          def __str__(self):
              return self.src.getName() + '->' + self.dest.getName()
      ```

    - ìœ í–¥ê·¸ë˜í”„ì˜ ì¼ë°˜ì ì¸ í‘œí˜„

      - ë°©í–¥ì´ ìˆëŠ” ê·¸ë˜í”„

        - ê°„ì„ ì€ ì˜¤ì§ í•œ ë°©í–¥ìœ¼ë¡œë§Œ ê°ˆ ìˆ˜ ìˆìŒ

      - ì¸ì ‘ í–‰ë ¬

        - row : sorce (s)
        - col : destination (d)
        - Cell[s, d] = 1
          - sì—ì„œ dë¡œ ê°€ëŠ” ê°„ì„ ì´ ì¡´ì¬í•˜ëŠ” ê²½ìš°
        - Cell[s, d] = 0
          - ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°
        - ìœ í–¥ ê·¸ë˜í”„ì—ì„œ í–‰ë ¬ì€ ëŒ€ì¹­ í–‰ë ¬ì´ ì•„ë‹˜

      - ì¸ì ‘ ë¦¬ìŠ¤íŠ¸

        - ê°  nodeë³„ ë„ì°©ì  ë¦¬ìŠ¤íŠ¸ì™€ ì—°ê´€

      - ```python
        class Digraph(object):
            """edges is a dict mapping each node to a list of
            its children"""
            def __init__(self):
                self.edges = {}
            def addNode(self, node):
                if node in self.edges:
                    raise ValueError('Duplicate node')
                else:
                    self.edges[node] = []
            def addEdge(self, edge):
                src = edge.getSource()
                dest = edge.getDestination()
                if not (src in self.edges and dest in self.edges):
                    raise ValueError('Node not in graph')
                self.edges[src].append(dest)
            def childrenOf(self, node):
                return self.edges[node]
            def hasNode(self, node):
                return node in self.edges
            def getNode(self, name):
                for n in self.edges:
                    if n.getName() == name:
                        return n
                raise NameError(name)
            def __str__(self):
                result = ''
                for src in self.edges:
                    for dest in self.edges[src]:
                        result = result + src.getName() + '->'\
                                 + dest.getName() + '\n'
                return result[:-1] #omit final newline
        ```

    - ê·¸ë˜í”„ì˜ ì¼ë°˜ì í‘œí˜„

      - ```python
        class Graph(Digraph):
            def addEdge(self, edge):
                Digraph.addEdge(self, edge)
                rev = Edge(edge.getDestination(), edge.getSource())
                Digraph.addEdge(self, rev)
        ```

        - ê·¸ë˜í”„ëŠ” ê°„ì„ ê³¼ ì—°ê´€ëœ ë°©í–¥ì„±ì„ ê°€ì§€ì§€ ì•ŠìŒ
          - ê°„ì„ ì€ ì–‘ë°©í–¥ ëª¨ë‘ í—ˆìš©
        - ì™œ ê·¸ë˜í”„ê°€ ìœ í–¥ ê·¸ë˜í”„ì˜ í•˜ìœ„ í´ë˜ìŠ¤ì¸ê°€? ëŒ€ì²´ ê·œì¹™ì„ ê¸°ì–µí•˜ëŠ”ê°€?
          - í´ë¼ì´ì–¸íŠ¸ ì½”ë“œê°€ ìƒìœ„ íƒ€ì… ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì‚¬ìš©í•´ë„ ì˜ ì‘ë™í•œë‹¤ë©´, í•˜ìœ„ íƒ€ì… ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒìœ„ íƒ€ì… ì¸ìŠ¤í„´ìŠ¤ë¡œ ëŒ€ì²´í•´ë„ ì˜ ì‘ë™í•´ì•¼í•¨
          - ìœ í–¥ ê·¸ë˜í”„ë¥¼ ì‚¬ìš©í•´ì„œ ì‘ë™í•˜ëŠ” í”„ë¡œê·¸ë¨ì´ë©´ ê·¸ë˜í”„ë¥¼ ì‚¬ìš©í•´ë„ ì˜ ì‘ë™í•¨ (ë°˜ëŒ€ëŠ” ì•„ë‹˜)

  ê·¸ë˜í”„ íƒìƒ‰

  - í•œ ë…¸ë“œì—ì„œ ë‹¤ë¥¸ ë…¸ë“œë¡œ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì€?

  - ìµœë‹¨ ê²½ë¡œ : ì‹œì‘ì ì˜ ì²« ê°„ì„  ~ ë„ì°©ì ì˜ ë§ˆì§€ë§‰ ê°„ì„ 

    - ì¼ì¢…ì˜ ì‚¬ìŠ¬ì²˜ëŸ¼ ë³´ì„

  - ì•Œê³ ì‹¶ì€ ê²ƒ : ìµœì†Œ ë‹¨ê³„ ìˆ˜

  - ê·¸ë˜í”„ ë§Œë“¤ê¸°

    - ```python
      def buildCityGraph(graphType):
          g = graphType()
          for name in ('Boston', 'Providence', 'New York', 'Chicago',
                       'Denver', 'Phoenix', 'Los Angeles'): #Create 7 nodes
              g.addNode(Node(name))
          g.addEdge(Edge(g.getNode('Boston'), g.getNode('Providence')))
          g.addEdge(Edge(g.getNode('Boston'), g.getNode('New York')))
          g.addEdge(Edge(g.getNode('Providence'), g.getNode('Boston')))
          g.addEdge(Edge(g.getNode('Providence'), g.getNode('New York')))
          g.addEdge(Edge(g.getNode('New York'), g.getNode('Chicago')))
          g.addEdge(Edge(g.getNode('Chicago'), g.getNode('Denver')))
          g.addEdge(Edge(g.getNode('Chicago'), g.getNode('Phoenix')))
          g.addEdge(Edge(g.getNode('Denver'), g.getNode('Phoenix')))
          g.addEdge(Edge(g.getNode('Denver'), g.getNode('New York')))
          g.addEdge(Edge(g.getNode('Los Angeles'), g.getNode('Boston')))
          return g
      ```

  - ìµœë‹¨ ê²½ë¡œ íƒìƒ‰

    - ê¹Šì´ ìš°ì„  íƒìƒ‰(Depth-First Search)

      - ë£¨íŠ¸ ë…¸ë“œì—ì„œ ì‹œì‘í•´ ë‹¤ìŒ ë¶„ê¸°ë¡œ ë„˜ì–´ê°€ê¸° ì „ì— í•´ë‹¹ ë¶„ê¸°ë¥¼ ëª¨ë‘ íƒìƒ‰í•˜ëŠ” ë°©ë²•

      - ë¬´í•œ ë£¨í”„ì˜ ê°€ëŠ¥ì„±ì´ ìˆê¸° ë•Œë¬¸ì— ê²½ë¡œë¥¼ ê¸°ì–µí•´ì•¼ í•¨

      - ì´ë¯¸ ë“¤ë €ë˜ ë…¸ë“œëŠ” ê°€ì§€ ì•ŠìŒ

        - ì²« ê°„ì„ ì„ ë”°ë¼ê°€ë‹¤ ì˜¬ë°”ë¥´ê²Œ ì™”ëŠ”ì§€ í™•ì¸, ì˜¬ë°”ë¥´ì§€ ì•Šìœ¼ë©´ ë£¨í”„
        - ëª©í‘œ ë…¸ë“œì— ë„ì°©í•˜ê±°ë‚˜ ì„ íƒì§€ê°€ ì—†ì–´ì§ˆ ë•Œê¹Œì§€ ë°˜ë³µ

      - íŠ¹ì§•

        - ìê¸° ìì‹ ì„ í˜¸ì¶œí•˜ëŠ” ìˆœí™˜ ì•Œê³ ë¦¬ì¦˜
        - ì–´ë–¤ ë…¸ë“œë¥¼ ë°©ë¬¸í–ˆëŠ”ì§€ë¥¼ ë°˜ë“œì‹œ í™•ì¸
        - ë¶„í• ì •ë³µì„ ì‚¬ìš© ê°€ëŠ¥
          - ì‹œì‘ì ì—ì„œ ì¤‘ê°„ì ê¹Œì§€ì˜ ê²½ë¡œì™€ ì¤‘ê°„ì ì—ì„œ ë„ì°©ì ê¹Œì§€ì˜ ê²½ë¡œì˜ ê²°í•©ì€ ì‹œì‘ì ì—ì„œ ë„ì°©ì ê¹Œì§€ì˜ ì „ì²´ ê²½ë¡œ

      - ```python
        def DFS(graph, start, end, path, shortest, toPrint = False):
            """Assumes graph is a Digraph; start and end are nodes;
                  path and shortest are lists of nodes
               Returns a shortest path from start to end in graph"""
            path = path + [start]
            if toPrint:
                print('Current DFS path:', printPath(path))
            if start == end:
                return path
            for node in graph.childrenOf(start):
                if node not in path: #avoid cycles
                    if shortest == None or len(path) < len(shortest):
                        newPath = DFS(graph, node, end, path, shortest,
                                      toPrint)
                        if newPath != None:
                            shortest = newPath
                elif toPrint:
                    print('Already visited', node)
            return shortest
        
        def shortestPath(graph, start, end, toPrint = False):
            """Assumes graph is a Digraph; start and end are nodes
               Returns a shortest path from start to end in graph"""
            return DFS(graph, start, end, [], None, toPrint)
        
        def shortestPath(graph, start, end, toPrint = False):
            """Assumes graph is a Digraph; start and end are nodes
               Returns a shortest path from start to end in graph"""
            return DFS(graph, start, end, [], None, toPrint)
        
        def testSP(source, destination):
            g = buildCityGraph(Digraph)
            sp = shortestPath(g, g.getNode(source), g.getNode(destination),
                              toPrint = True)
            if sp != None:
                print('Shortest path from', source, 'to',
                      destination, 'is', printPath(sp))
            else:
                print('There is no path from', source, 'to', destination)
        
        testSP('Chicago', 'Boston')
        print()
        testSP('Boston', 'Phoenix')
        print()
        ```

      - 

    - ë„ˆë¹„ ìš°ì„  íƒìƒ‰(Breadth-First Search)

      - ë£¨íŠ¸ ë…¸ë“œì—ì„œ ì‹œì‘í•´ ì¸ì ‘í•œ ë…¸ë“œë¥¼ ë¨¼ì € íƒìƒ‰í•˜ëŠ” ë°©ë²•

      - íŠ¹ì§•

        - ë£¨íŠ¸ ë…¸ë“œì—ì„œ ëª©í‘œ ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ë³´ì¥

      - ```python
        printQueue = True 
        
        def BFS(graph, start, end, toPrint = False):
            """Assumes graph is a Digraph; start and end are nodes
               Returns a shortest path from start to end in graph"""
            initPath = [start]
            pathQueue = [initPath]
            while len(pathQueue) != 0:
                #Get and remove oldest element in pathQueue
                if printQueue:
                    print('Queue:', len(pathQueue))
                    for p in pathQueue:
                        print(printPath(p))
                tmpPath = pathQueue.pop(0)
                if toPrint:
                    print('Current BFS path:', printPath(tmpPath))
                    print()
                lastNode = tmpPath[-1]
                if lastNode == end:
                    return tmpPath
                for nextNode in graph.childrenOf(lastNode):
                    if nextNode not in tmpPath:
                        newPath = tmpPath + [nextNode]
                        pathQueue.append(newPath)
            return None
        
        def shortestPath(graph, start, end, toPrint = False):
            """Assumes graph is a Digraph; start and end are nodes
               Returns a shortest path from start to end in graph"""
            return BFS(graph, start, end, toPrint)
            
        testSP('Boston', 'Phoenix')
        ```

        - QueuëŠ” pathì˜ ë¦¬ìŠ¤íŠ¸
        - pathëŠ” edgeì˜ ë¦¬ìŠ¤íŠ¸

    - ìµœì†Œ ê°€ì¤‘ì¹˜ ê²½ë¡œ

      - ê°„ì„ ì˜ ìˆ˜ê°€ ì•„ë‹Œ, ê°„ì„ ìœ¼ ã…£ê°€ì¤‘ì¹˜ì˜ í•©ì„ ìµœì†Œí™” í•˜ë ¤í•¨
      - DFSëŠ” ì´ë¥¼ ìœ„í•´ ì‰½ê²Œ ìˆ˜ì • ê°€ëŠ¥
      - BFSëŠ” ë¶ˆê°€ëŠ¥
        - ìµœì†Œ ê°€ì¤‘ì¹˜ ê²½ë¡œëŠ” ìµœì†Œ ë£¨í”„ ìˆ˜ë³´ë‹¤ ë” ë§ì€ ë£¨í”„ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆê¸° ë•Œë¬¸
    
  - ë³µìŠµ
  
    - ê·¸ë˜í”„ëŠ” ë©‹ì§
      - ë§ì€ ê²ƒë“¤ì˜ ëª¨ë¸ì„ ë§Œë“œëŠ”ë° ì¢‹ì€ ë°©ë²•
        - ë¬¼ê±´ë“¤ ê°„ì˜ ê´€ê³„ë¥¼ ë‹´ê³  ìˆìŒ
      - ë§ì€ ì¤‘ìš”í•œ ë¬¸ì œë“¤ì€ ìš°ë¦¬ê°€ ì´ë¯¸ í•´ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì„ ì•Œê³  ìˆëŠ” ê·¸ë˜í”„ ìµœì í™” ë¬¸ì œë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŒ
    - ê¹Šì´ ìš°ì„  íƒìƒ‰ê³¼ ë„ˆë¹„ ìš°ì„  íƒìƒ‰ì€ ì¤‘ìš”í•œ ì•Œê³ ë¦¬ì¦˜
      - ë§ì€ ë¬¸ì œë¥¼ í‘¸ëŠ” ë° ì“°ì¼ ìˆ˜ ìˆìŒ 